/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: swquinc <swquinc@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/01/18 22:34:42 by swquinc           #+#    #+#             */
/*   Updated: 2021/02/13 01:56:00 by swquinc          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H
# include <stdlib.h> // malloc, free, exit
// malloc - выделяет динамическую память. В случае ошибки возвращает 0. Записывает код ошибки в errno.
// free - освобождает динамическую память.
// exit - завершает программу, не забываем чистить память. Аргумент EXIT_SUCCES или EXIT_FAILURE.
# include <unistd.h> // write, open, read, close, fork, getcwd, chdir, execve, dup, dup2, pipe
// write - записывает в файловый дескриптор n байт из буфера. В случае ошибки возвращает -1. Записывает код ошибки в errno.
// на самом деле open присваивает файлу код-ссылку, по которому мы можем обратится к файлу.
// read - считывает из файлового дескриптора и записывает n байт в буфер. В случае ошибки повторяет поведение open.
// close - удаляет файловый дескрпитор. В случае ошибки повторяет поведение read.
// fork - дублирует текущий процесс. Иными словами, создает дочерний процесс.
// getcwd - записывает в буфер абсолютный путь к рабочей директории. В случае ошибки возвращает NULL. Записывает код ошибки в errno. ДЛЯ CD. PWD.
// chdir - меняет текущую рабочую директорию. В случае ошибки возврашает -1. Записывает код ошибки в errno. FOR CD.
// execve - очищает процесс, тем самым создавая новый чистый процесс. В случае ошибки возвращает -1. Записывает код ошибки в errno.
// dup - создает новый fd и копирует в него указанный fd.
// dup2 -  создает новый fd, с конкретно указанным номером и копирует в него указанный fd.
// pipe - создает пару файловых дескрипторов, которые связаны друг с другом каналом. Данные записанные в fildes[1] могут быть прочитаны из fildes[0]. Походу это нужно для |.
#include <fcntl.h> //open
// open - открывает файл с указаным режимом доступа. Возвращает файловый дескрпитор. В случае ошибки повторяет поведение write.
# include <sys/wait.h> // wait, wait3, wait4, waitpid
// wait - приостанавливает работу текущего процесса до тех пор, пока один из дочерних процессов не завершится.
// wait3 - приостанавливает работу текущего процесса до тех пор, пока один из дочерних процессов не завершится. Также возвращает в структуре информацию о процессе. 
// wait4 - приостанавливает работу текущего процесса до тех пор, пока указанный дочерний процесс не завершится. Также возвращает в структуре информацию о процессе. 
// waitpid - приостанавливает работу текущего процесса до тех пор, пока указанный дочерний процесс не завершится.
# include <signal.h> // signal, kill
// signal - обработка клавиш (сигналов). 
// kill - отправляет указанный сигнал в указанный pid. Если pid 0, то всем. Если -1 всем, кроме процессу 1. Если sig 0, то сигнал не отправляется, а только выполняется проверка на ошибку.
# include <sys/stat.h> //stat, lstat, fstat
// stat - Возвращает информацию о файле. В качестве аргумента принимает путь в char*. В случае ошибки возвращает -1. Код ошибки в errno.
// lstat - Возвращает информацию о файле. В качестве аргумента принимает путь в char*. Но если передается символьная ссылка, то будет возвращена информация о ссылке. В случае ошибки возвращает -1. Код ошибки в errno. 
// fstat - Возвращает информацию о файле. В качестве аргумента принимает FILE*. В случае ошибки возвращает -1. Код ошибки в errno.  
# include <dirent.h> //opendir, readdir, closedir
// opendir - открывает поток каталога, возвращает структуру DIR*, которая содержит информацию о каталоге.
// readdir - читает загаловки файлов в каталоге по очереди. По одному загаловку за раз.
// closedir - закрывает каталог каталога.
# include <sys/errno.h> //errno
// errno - глобальная переменная, которая содержит код последней ошибки.
# include <stdio.h> // strerror
// strerror - возвращает текстовое значение ошибки. Аргумент - код ошибки.
# include <limits.h>
# include "libft.h"
# include "structures.h"

int     parser(t_cmd **cmd, char *line);
int		lexer(char *line);
int		parse_env(t_main *main);
int     parse_redir(t_main *main);
int		executor(t_main *main);
int		exec_cd(t_main *main, t_cmd *cmd); // переход в указанный каталог. Если без аргументов, то переход в $HOME.
void	exec_echo(t_main *main, t_cmd *cmd); // выводит строку, может записать строку в файл, вывод значения переменной.
void	exec_env(t_main *main, t_cmd *cmd); // без аргументов и опций. Выводит переменные окружения.
void	exec_exit(t_main *main, t_cmd *cmd); // завершает программу, и возвращает код ошибки. $? - походу придется создать переменную dollar_quest, которая будет выводится при подаче $?. По-умолчанию она 127. Перед каждым exit нужно сначала передать код в переменную dollar_quest.
int		exec_export(t_main *main, t_cmd *cmd); // передает дочернему процессу указанную переменную окружения. Передаем структуру или двумерный массив для дочки???
int		exec_pwd(t_main *main, t_cmd *cmd); // выводит переменную PWD.
int		exec_unset(t_main *main, t_cmd *cmd); // удаляет переменную окружения.
void	exec(t_main *main, t_cmd *cmd); // выполняем исполняемые файлы.
void	ft_perror(const char *str);
int		error_handler(int code, char *str);
void	ignore_squit(int code);
void	ignore_sint(int code);
void	quit_child(int code);
void	kill_child(int code);
char	**ft_2arraydup(char **array);
char	**ft_stradd(char **array, char *str);
int		ft_strchr_index(const char *s, int c);
int		var_handler(t_main *main, char **src, int a);
void	ft_free_2array(char **array);

#endif
